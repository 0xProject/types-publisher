"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const yargs = require("yargs");
const common_1 = require("./lib/common");
const npm_client_1 = require("./lib/npm-client");
const package_generator_1 = require("./lib/package-generator");
const packages_1 = require("./lib/packages");
const settings_1 = require("./lib/settings");
const versions_1 = require("./lib/versions");
const io_1 = require("./util/io");
const logging_1 = require("./util/logging");
const util_1 = require("./util/util");
const packageName = "types-registry";
const registryOutputPath = util_1.joinPaths(settings_1.outputPath, packageName);
const readme = `This package contains a listing of all packages published to the @types scope on NPM.
Generated by [types-publisher](https://github.com/Microsoft/types-publisher).`;
const registryInstallDir = util_1.joinPaths(__dirname, "..", "install-types-registry");
if (!module.parent) {
    const dry = !!yargs.argv.dry;
    util_1.done(main(common_1.Options.defaults, dry));
}
function main(options, dry) {
    return __awaiter(this, void 0, void 0, function* () {
        const [log, logResult] = logging_1.logger();
        log("=== Publishing types-registry ===");
        if (yield shouldPublishNewRegistry(options, log)) {
            log("New packages have been added, so publishing a new registry.");
            yield generateAndPublishRegistry(log, dry);
        }
        else {
            log("No new packages published, so no need to publish new registry.");
        }
        yield logging_1.writeLog("publish-registry.md", logResult());
    });
}
exports.default = main;
function shouldPublishNewRegistry(options, log) {
    return __awaiter(this, void 0, void 0, function* () {
        const oldRegistry = yield downloadOldRegistry();
        const packages = yield packages_1.AllPackages.read(options);
        const oldPackagesList = Object.keys(oldRegistry.entries);
        const newPackagesList = packages.allTypings().map(t => t.name);
        const { leftExclusive: olds, rightExclusive: news } = util_1.setDifference(oldPackagesList, newPackagesList);
        let anyDiff = false;
        for (const old of olds) {
            anyDiff = true;
            log(`Package has been removed: ${old}`);
        }
        for (const nu of news) {
            anyDiff = true;
            log(`Package has been added: ${nu}`);
        }
        return anyDiff;
    });
}
function downloadOldRegistry() {
    return __awaiter(this, void 0, void 0, function* () {
        yield clean(); // Just to be sure nothing was left behind
        yield util_1.execAndThrowErrors("npm install", registryInstallDir);
        const res = io_1.readJson(util_1.joinPaths(registryInstallDir, "node_modules", "types-registry", "index.json"));
        yield clean();
        return res;
        function clean() {
            return __awaiter(this, void 0, void 0, function* () {
                yield fs_extra_1.remove(util_1.joinPaths(registryInstallDir, "node_modules"));
                yield fs_extra_1.remove(util_1.joinPaths(registryInstallDir, "package-lock.json"));
            });
        }
    });
}
function generateAndPublishRegistry(log, dry) {
    return __awaiter(this, void 0, void 0, function* () {
        // Don't include not-needed packages in the registry.
        const typings = yield packages_1.AllPackages.readTypings();
        const last = yield versions_1.fetchLastPatchNumber(packageName);
        const packageJson = generatePackageJson(last + 1);
        yield generate(typings, packageJson, log);
        yield publish(packageJson, dry);
    });
}
function generate(typings, packageJson, log) {
    return __awaiter(this, void 0, void 0, function* () {
        yield package_generator_1.clearOutputPath(registryOutputPath, log);
        yield writeOutputFile("package.json", packageJson);
        yield writeOutputFile("index.json", generateRegistry(typings));
        yield writeOutputFile("README.md", readme);
        function writeOutputFile(filename, content) {
            return io_1.writeJson(util_1.joinPaths(registryOutputPath, filename), content);
        }
    });
}
function publish(packageJson, dry) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield npm_client_1.default.create();
        yield client.publish(registryOutputPath, packageJson, dry);
    });
}
function generatePackageJson(patch) {
    return {
        name: packageName,
        version: `0.1.${patch}`,
        description: "A registry of TypeScript declaration file packages published within the @types scope.",
        repository: {
            type: "git",
            url: "https://github.com/Microsoft/types-publisher.git"
        },
        keywords: [
            "TypeScript",
            "declaration",
            "files",
            "types",
            "packages"
        ],
        author: "Microsoft Corp.",
        license: "MIT"
    };
}
function generateRegistry(typings) {
    const entries = {};
    for (const { name } of typings) {
        entries[name] = 1;
    }
    return { entries };
}
//# sourceMappingURL=publish-registry.js.map